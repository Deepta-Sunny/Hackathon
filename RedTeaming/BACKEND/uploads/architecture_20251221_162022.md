# C4 Model Diagrams
## E-Commerce AI Chatbot Service

**Document Version:** 1.0  
**Last Updated**: November 14, 2025

---

## Table of Contents

1. [Introduction](#introduction)
2. [C4 Level 1: System Context](#c4-level-1-system-context)
3. [C4 Level 2: Container Diagram](#c4-level-2-container-diagram)
4. [C4 Level 3: Component Diagram](#c4-level-3-component-diagram)
5. [C4 Level 4: Code Diagrams](#c4-level-4-code-diagrams)
6. [Deployment View](#deployment-view)

---

## Introduction

This document presents the **C4 model** (Context, Container, Component, Code) architecture diagrams for the E-Commerce AI Chatbot Service. The C4 model provides a hierarchical approach to visualizing software architecture at different abstraction levels:

- **Level 1 (Context)**: System in relation to users and external systems
- **Level 2 (Container)**: High-level technology choices and communication protocols
- **Level 3 (Component)**: Internal structure of containers
- **Level 4 (Code)**: Implementation details of critical components

These diagrams are designed using **Mermaid.js** syntax for easy integration with documentation platforms.

---

## C4 Level 1: System Context

### Overview
Shows the E-Commerce Chatbot in its ecosystem, including external users and systems.

```mermaid
C4Context
    title System Context Diagram - E-Commerce AI Chatbot

    Person(customer, "Customer", "End-user seeking product information and support")
    
    System(chatbot, "E-Commerce Chatbot", "AI-powered conversational assistant for product discovery and customer support")
    
    System_Ext(azureOpenAI, "Azure OpenAI", "GPT-4 for NLU, generation, embeddings")
    System_Ext(azureSQL, "Azure SQL Database", "Product catalog and inventory data")
    System_Ext(vectorDB, "ChromaDB", "Embedded vector database for semantic search")
    
    Rel(customer, chatbot, "Asks questions, searches products", "WebSocket")
    Rel(chatbot, azureOpenAI, "Classifies intent, generates responses, creates embeddings", "HTTPS")
    Rel(chatbot, azureSQL, "Queries product data", "SQL/TDS")
    Rel(chatbot, vectorDB, "Searches products/FAQs semantically", "Local API")
    
    UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
```

### Key Relationships

| Source | Target | Purpose | Protocol |
|--------|--------|---------|----------|
| Customer | Chatbot | Product search, FAQs, support | WebSocket |
| Chatbot | Azure OpenAI | Intent classification, response generation | HTTPS/REST |
| Chatbot | Azure SQL | Product catalog queries | SQL/TDS |
| Chatbot | ChromaDB | Semantic search (products, FAQs) | Python API |

### Business Context

**Primary Users**:
- E-commerce customers seeking product information
- Customers requiring purchase guidance
- Users with product-related questions

**External Dependencies**:
- **Azure OpenAI**: Critical dependency for AI capabilities (GPT-4, embeddings)
- **Azure SQL Database**: Source of truth for product inventory
- **ChromaDB**: Enhances search with semantic understanding

---

## C4 Level 2: Container Diagram

### Overview
Shows the runtime containers (applications, data stores) and their interactions.

```mermaid
C4Container
    title Container Diagram - E-Commerce AI Chatbot Service

    Person(customer, "Customer", "E-commerce website user")

    Container_Boundary(chatbotSystem, "Chatbot Service") {
        Container(webApp, "FastAPI Application", "Python 3.13, FastAPI", "Handles WebSocket connections and HTTP endpoints")
        Container(workflowEngine, "LangGraph Workflow", "Python, LangGraph", "Orchestrates conversation flow across 7 nodes")
        Container(vectorStore, "ChromaDB", "ChromaDB 1.3.4", "Stores product and FAQ embeddings (70 products, 39 FAQs)")
    }

    System_Ext(azureOpenAI, "Azure OpenAI Service", "GPT-4 (chat, intent), text-embedding-ada-002")
    SystemDb_Ext(azureSQL, "Azure SQL Database", "Product catalog (neucommerce.database.windows.net)")

    Rel(customer, webApp, "Sends queries, receives responses", "WebSocket (port 8000)")
    Rel(webApp, workflowEngine, "Invokes workflow with user query", "Python API")
    
    Rel(workflowEngine, azureOpenAI, "Intent classification, response generation, safety validation", "HTTPS/REST")
    Rel(workflowEngine, azureSQL, "SQL queries for product search", "pyodbc/SQL")
    Rel(workflowEngine, vectorStore, "Semantic similarity search", "ChromaDB API")
    
    Rel(vectorStore, azureOpenAI, "Generate embeddings (indexing)", "HTTPS/REST")

    UpdateLayoutConfig($c4ShapeInRow="2", $c4BoundaryInRow="1")
```

### Container Details

#### 1. FastAPI Application
- **Technology**: Python 3.13, FastAPI 0.104.1
- **Responsibilities**:
  - WebSocket connection management
  - Request/response handling
  - Health check endpoints
  - Message streaming to clients
- **Scaling**: Horizontal (with sticky sessions)
- **Port**: 8000 (HTTP/WebSocket)

#### 2. LangGraph Workflow Engine
- **Technology**: LangGraph 1.0.2, LangChain 1.0.5
- **Responsibilities**:
  - Workflow orchestration (7 nodes)
  - State management (InMemorySaver)
  - Conditional routing
  - Interrupt handling for clarifications
- **State Storage**: In-memory (thread-based)
- **Concurrency**: Supports multiple concurrent conversations

#### 3. ChromaDB Vector Store
- **Technology**: ChromaDB 1.3.4
- **Data**:
  - Product embeddings (70 products)
  - FAQ embeddings (39 documents)
- **Embedding Model**: text-embedding-ada-002 (Azure OpenAI)
- **Storage**: Local disk (chroma_db/)

#### 4. Azure OpenAI Service
- **Models**:
  - GPT-4 (gpt-4-32k) for chat and intent classification
  - text-embedding-ada-002 for embeddings
- **Usage**:
  - Intent classification in router_node
  - Response generation in retrieval_node, faq_node
  - Safety validation in guardrail_node
  - Embedding generation for indexing

#### 5. Azure SQL Database
- **Database**: ECommerce
- **Server**: neucommerce.database.windows.net
- **Schema**:
  - Products table (ProductName, Category, Price, Description, Availability)
  - Categories: Laptops, Mobile, Camera, AC
- **Access**: Read-only queries via pyodbc

### Communication Protocols

```mermaid
sequenceDiagram
    participant Customer
    participant FastAPI
    participant Workflow
    participant OpenAI
    participant SQL
    participant Chroma

    Customer->>FastAPI: WebSocket: {"query": "Find laptop under 1000"}
    FastAPI->>Workflow: invoke(query, thread_id)
    
    Workflow->>OpenAI: Classify intent (router_node)
    OpenAI-->>Workflow: intent="product_search"
    
    Workflow->>Chroma: Similarity search
    Chroma-->>Workflow: Top 5 similar products
    
    Workflow->>OpenAI: Generate SQL query
    OpenAI-->>Workflow: SQL query
    
    Workflow->>SQL: Execute query
    SQL-->>Workflow: Product results
    
    Workflow->>OpenAI: Format response
    OpenAI-->>Workflow: Natural language response
    
    Workflow-->>FastAPI: final_response
    FastAPI-->>Customer: WebSocket: {"response": "..."}
```

---

## C4 Level 3: Component Diagram

### Overview
Shows internal components of the LangGraph Workflow container.

```mermaid
C4Component
    title Component Diagram - LangGraph Workflow Engine

    Container_Boundary(workflowEngine, "LangGraph Workflow Engine") {
        Component(startNode, "Start Node", "Python", "Greets user, detects first message")
        Component(guardrailNode, "Guardrail Node", "Python", "Security validation (pattern + LLM)")
        Component(routerNode, "Router Node", "Python", "Intent classification with GPT-4")
        Component(clarifyNode, "Clarifying Node", "Python", "Requests user clarification")
        Component(retrievalNode, "Retrieval Node", "Python", "Hybrid search (vector + SQL)")
        Component(faqNode, "FAQ Node", "Python", "FAQ semantic search")
        Component(fallbackNode, "Fallback Node", "Python", "Handles unknown queries")
        
        Component(stateManager, "State Manager", "InMemorySaver", "Thread-based state persistence")
        Component(dbManager, "Database Manager", "Python", "Manages SQL and ChromaDB connections")
    }

    System_Ext(azureOpenAI, "Azure OpenAI", "GPT-4, Embeddings")
    SystemDb_Ext(azureSQL, "Azure SQL Database", "Product catalog")
    ContainerDb(vectorStore, "ChromaDB", "Vector DB", "Product/FAQ embeddings")

    Rel(startNode, guardrailNode, "Routes to", "Workflow edge")
    Rel(guardrailNode, routerNode, "If safe", "Workflow edge")
    Rel(routerNode, clarifyNode, "If needs_clarification", "Conditional edge")
    Rel(routerNode, retrievalNode, "If product_search", "Conditional edge")
    Rel(routerNode, faqNode, "If faq", "Conditional edge")
    Rel(routerNode, fallbackNode, "If unknown", "Conditional edge")
    Rel(clarifyNode, routerNode, "After clarification", "Workflow edge")
    
    Rel(routerNode, azureOpenAI, "Classify intent", "HTTPS")
    Rel(guardrailNode, azureOpenAI, "Safety validation", "HTTPS")
    Rel(retrievalNode, azureOpenAI, "Generate SQL, format response", "HTTPS")
    Rel(faqNode, azureOpenAI, "Format FAQ response", "HTTPS")
    
    Rel(retrievalNode, dbManager, "Query products", "Python API")
    Rel(faqNode, dbManager, "Search FAQs", "Python API")
    
    Rel(dbManager, azureSQL, "Execute SQL", "pyodbc")
    Rel(dbManager, vectorStore, "Similarity search", "ChromaDB API")
    
    Rel(stateManager, startNode, "Manages state", "Python API")
    Rel(stateManager, guardrailNode, "Manages state", "Python API")
    Rel(stateManager, routerNode, "Manages state", "Python API")

    UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
```

### Component Responsibilities

#### Workflow Nodes

| Component | Responsibility | Decision Logic |
|-----------|---------------|----------------|
| **Start Node** | Entry point, greeting detection | If first message → welcome; else → continue |
| **Guardrail Node** | Security validation | If unsafe → reject; else → route to router |
| **Router Node** | Intent classification | Routes to clarify/retrieval/FAQ/fallback based on intent |
| **Clarifying Node** | Interactive clarification | Interrupts workflow, waits for user input |
| **Retrieval Node** | Product search | Vector search → SQL generation → SQL execution → formatting |
| **FAQ Node** | FAQ semantic search | Vector search in FAQ collection → format response |
| **Fallback Node** | Unknown query handling | Returns helpful default message |

#### Support Components

| Component | Responsibility | Technology |
|-----------|---------------|------------|
| **State Manager** | Thread-based state persistence | InMemorySaver (LangGraph) |
| **Database Manager** | SQL and ChromaDB connection pooling | pyodbc, ChromaDB client |

### Workflow Routing Logic

```mermaid
flowchart TD
    START[start_node] --> GUARD[guardrail_node]
    GUARD -->|Safe| ROUTER[router_node]
    GUARD -->|Unsafe| END1[__end__: Rejected]
    
    ROUTER -->|product_search| RETRIEVE[retrieval_node]
    ROUTER -->|faq| FAQ[faq_node]
    ROUTER -->|clarification_needed| CLARIFY[clarifying_node]
    ROUTER -->|unknown| FALLBACK[fallback_node]
    
    CLARIFY -->|Has category| RETRIEVE
    CLARIFY -->|No category| ROUTER
    
    RETRIEVE --> END2[__end__: Response]
    FAQ --> END3[__end__: Response]
    FALLBACK --> END4[__end__: Response]
    
    style GUARD fill:#ff6b6b
    style ROUTER fill:#4ecdc4
    style CLARIFY fill:#ffe66d
    style RETRIEVE fill:#95e1d3
    style FAQ fill:#95e1d3
    style FALLBACK fill:#f38181
```

---

## C4 Level 4: Code Diagrams

### Overview
Detailed code-level diagrams for critical components.

---

### 4.1 Router Node - Intent Classification

```mermaid
flowchart TD
    A[router_node receives state] --> B{Check previous<br/>messages}
    B -->|< 2 messages| C[Extract latest query]
    B -->|≥ 2 messages| D[Use last 5 messages<br/>for context]
    
    C --> E[Create LLM with<br/>tool binding]
    D --> E
    
    E --> F[Invoke LLM with<br/>IntentClassification tool]
    
    F --> G{LLM returns<br/>tool call?}
    G -->|Yes| H[Extract intent from<br/>tool arguments]
    G -->|No| I[Fallback: unknown]
    
    H --> J{Intent type?}
    J -->|product_search| K[Extract search_criteria<br/>category, max_price]
    J -->|faq| L[Set intent = faq]
    J -->|clarification_needed| M[Set needs_clarification]
    J -->|unknown| N[Set intent = unknown]
    
    K --> O[Update state with<br/>search_criteria]
    L --> P[Update state with<br/>intent]
    M --> Q[Update state with<br/>needs_clarification=True]
    N --> R[Update state with<br/>intent=unknown]
    
    O --> S[Return updated state]
    P --> S
    Q --> S
    R --> S
    I --> S
    
    style E fill:#4ecdc4
    style H fill:#95e1d3
    style K fill:#ffe66d
```

**Code Structure**:
```python
def router_node(state: WorkflowState) -> WorkflowState:
    """
    Intent classification using GPT-4 with tool binding
    """
    # Step 1: Prepare conversation context
    messages = get_last_n_messages(state["messages"], n=5)
    
    # Step 2: Bind IntentClassification tool to LLM
    llm_with_tools = get_azure_llm(temperature=0.0).bind_tools(
        [IntentClassification],
        tool_choice="IntentClassification"
    )
    
    # Step 3: Invoke LLM
    response = llm_with_tools.invoke(messages)
    
    # Step 4: Extract intent from tool call
    if response.tool_calls:
        intent_data = response.tool_calls[0]["args"]
        return {
            "intent": intent_data["intent"],
            "search_criteria": intent_data.get("search_criteria"),
            "needs_clarification": intent_data["intent"] == "clarification_needed"
        }
    
    # Fallback
    return {"intent": "unknown"}
```

---

### 4.2 Retrieval Node - Hybrid Search

```mermaid
flowchart TD
    A[retrieval_node receives state] --> B[Extract search_criteria<br/>from state]
    
    B --> C{Step 1:<br/>Vector Search}
    C --> D[ChromaDB similarity search]
    D --> E[Get top 5 products]
    
    B --> F{Step 2:<br/>SQL Generation}
    F --> G[Create SQL prompt with<br/>category, max_price]
    G --> H[Invoke GPT-4 to<br/>generate SQL query]
    H --> I[Parse SQL query]
    
    I --> J{Step 3:<br/>SQL Execution}
    J --> K[Execute SQL on<br/>Azure SQL Database]
    K --> L[Get filtered products]
    
    E --> M[Combine vector<br/>and SQL results]
    L --> M
    
    M --> N[Deduplicate by<br/>ProductID]
    N --> O[Rank results<br/>by relevance]
    
    O --> P[Format response<br/>with GPT-4]
    P --> Q[Update state with<br/>final_response]
    Q --> R[Return updated state]
    
    style C fill:#95e1d3
    style F fill:#4ecdc4
    style J fill:#ffe66d
    style P fill:#f38181
```

**Three-Step Process**:

**Step 1: Vector Search**
```python
# Semantic similarity search in ChromaDB
vector_results = chroma_collection.query(
    query_texts=[user_query],
    n_results=5,
    where={"category": category} if category else None
)
```

**Step 2: SQL Generation**
```python
# Generate SQL query using GPT-4
sql_prompt = f"""
Generate SQL query to find products matching:
- Category: {category}
- Max Price: {max_price}
- Description: {user_query}
"""
sql_query = llm.invoke(sql_prompt)
```

**Step 3: Execution & Combination**
```python
# Execute SQL query
sql_results = db_manager.execute_sql(sql_query)

# Combine and deduplicate
all_products = vector_results + sql_results
unique_products = deduplicate_by_id(all_products)
ranked_products = rank_by_relevance(unique_products, user_query)
```

---

### 4.3 Clarifying Node - Interrupt Pattern

```mermaid
sequenceDiagram
    participant User
    participant Workflow
    participant ClarifyNode
    participant RouterNode

    User->>Workflow: "I need a product"
    Workflow->>RouterNode: Classify intent
    RouterNode->>Workflow: intent=clarification_needed
    
    Workflow->>ClarifyNode: Execute node
    ClarifyNode->>ClarifyNode: Check missing info
    
    alt Missing Category
        ClarifyNode->>Workflow: Command(resume="category")
        Workflow-->>User: "What category? (Laptop/Mobile/Camera/AC)"
        Note over Workflow: Workflow PAUSED
        
        User->>Workflow: "Laptop"
        Workflow->>ClarifyNode: Resume with value="Laptop"
        ClarifyNode->>ClarifyNode: Update state.category
        ClarifyNode->>Workflow: Route to retrieval_node
    else Missing Price
        ClarifyNode->>Workflow: Command(resume="max_price")
        Workflow-->>User: "What's your budget?"
        User->>Workflow: "1000"
        ClarifyNode->>ClarifyNode: Update state.max_price
    end
    
    ClarifyNode->>Workflow: Updated state
    Workflow->>RouterNode: Re-classify with new info
```

**Interrupt Implementation**:
```python
def clarifying_node(state: WorkflowState) -> Command:
    """
    Interrupt workflow to request clarification
    """
    # Check what information is missing
    if not state.get("category"):
        return Command(
            update={
                "messages": ["Please specify category: Laptop, Mobile, Camera, or AC"]
            },
            resume="category"  # Wait for user input
        )
    
    if not state.get("max_price"):
        return Command(
            update={
                "messages": ["What's your maximum budget?"]
            },
            resume="max_price"
        )
    
    # All information available, route to retrieval
    return Command(goto="retrieval_node")
```

---

### 4.4 Guardrail Node - Security Validation

```mermaid
flowchart TD
    A[guardrail_node receives state] --> B[Extract user_query]
    
    B --> C{Stage 1:<br/>Pattern Matching}
    C --> D[Check against<br/>blocked patterns]
    
    D --> E{Match found?}
    E -->|Yes| F[Set final_response:<br/>Security warning]
    E -->|No| G{Stage 2:<br/>LLM Validation}
    
    F --> H[Return state<br/>route to END]
    
    G --> I[Create safety prompt]
    I --> J[Invoke GPT-4 with<br/>system: safety validator]
    
    J --> K{LLM verdict?}
    K -->|UNSAFE| L[Set final_response:<br/>Rejected query]
    K -->|SAFE| M[Continue to<br/>router_node]
    
    L --> N[Return state<br/>route to END]
    M --> O[Return state<br/>route to router]
    
    style C fill:#ff6b6b
    style G fill:#ffe66d
    style M fill:#95e1d3
```

**Blocked Patterns**:
```python
BLOCKED_PATTERNS = [
    "jailbreak",
    "ignore previous",
    "ignore instructions",
    "act as",
    "pretend you are",
    "roleplay",
    "system prompt"
]
```

**Two-Stage Validation**:
```python
def guardrail_node(state: WorkflowState) -> WorkflowState:
    query = state["user_query"].lower()
    
    # Stage 1: Pattern matching
    for pattern in BLOCKED_PATTERNS:
        if pattern in query:
            return {
                "final_response": "Your query contains unsafe content.",
                "intent": "blocked"
            }
    
    # Stage 2: LLM safety check
    safety_prompt = f"Is this query safe? {query}"
    verdict = llm.invoke(safety_prompt)
    
    if "UNSAFE" in verdict:
        return {
            "final_response": "Query rejected by security filter.",
            "intent": "blocked"
        }
    
    # Safe query
    return {"intent": "safe"}
```

---

## Deployment View

### Container Deployment

```mermaid
C4Deployment
    title Deployment Diagram - E-Commerce AI Chatbot

    Deployment_Node(client, "Client Browser", "Web Browser") {
        Container(webapp, "Web Application", "JavaScript", "E-commerce frontend with WebSocket")
    }

    Deployment_Node(azure, "Azure Cloud", "Cloud Platform") {
        Deployment_Node(appService, "Azure App Service", "PaaS") {
            Container(fastapi, "FastAPI App", "Python 3.13", "Chatbot service (port 8000)")
            ContainerDb(chromadb, "ChromaDB", "Vector DB", "Embedded database")
        }
        
        Deployment_Node(openai, "Azure OpenAI", "AI Service") {
            Container(gpt4, "GPT-4", "LLM", "Chat and intent classification")
            Container(embeddings, "Embeddings", "Model", "text-embedding-ada-002")
        }
        
        Deployment_Node(sqlServer, "Azure SQL", "Database Service") {
            ContainerDb(sqldb, "ECommerce DB", "SQL Database", "Product catalog")
        }
    }

    Rel(webapp, fastapi, "WebSocket", "wss://")
    Rel(fastapi, chromadb, "Query", "Local API")
    Rel(fastapi, gpt4, "API calls", "HTTPS")
    Rel(fastapi, embeddings, "Generate embeddings", "HTTPS")
    Rel(fastapi, sqldb, "SQL queries", "TDS 1433")

    UpdateLayoutConfig($c4ShapeInRow="2", $c4BoundaryInRow="1")
```

### Infrastructure Components

| Component | Service | Configuration | Scaling |
|-----------|---------|---------------|---------|
| **Web App** | Azure App Service (B2) | Python 3.13 runtime | Horizontal (max 3 instances) |
| **Vector DB** | ChromaDB (embedded) | Local disk storage | Scales with app instances |
| **LLM** | Azure OpenAI GPT-4 | gpt-4-32k deployment | Serverless (auto-scale) |
| **Embeddings** | Azure OpenAI | text-embedding-ada-002 | Serverless (auto-scale) |
| **SQL Database** | Azure SQL Database | Standard S2 tier | Built-in high availability |

---

## Diagram Conventions

### Color Coding

- **Red** (#ff6b6b): Security-related components (Guardrails)
- **Teal** (#4ecdc4): Core processing nodes (Router)
- **Green** (#95e1d3): Data retrieval (Retrieval, FAQ)
- **Yellow** (#ffe66d): User interaction (Clarifying)
- **Pink** (#f38181): Error handling (Fallback)

### Notation

- **Solid Lines**: Synchronous calls
- **Dashed Lines**: Asynchronous/Event-driven
- **Bold Borders**: Critical path components
- **Dotted Borders**: External systems

---

## Revision History

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-11-14 | 1.0 | Initial C4 model documentation | Engineering Team |

---

**Document Control**
- **Review Cycle**: On architecture changes
- **Approvers**: Architecture Team, Tech Lead
- **Next Review**: 2026-02-01
